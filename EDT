#include <iostream>
#include <string>
#include <math.h>
using namespace std;

const char UNIDAD_IMAGINARIA = 'j';

struct ComplejoBinomica {
	double a;
	double b;
};

struct ComplejoPolar {
	double modulo;
	double argumento;
};

void binomica(double a, double b) {
	cout << endl << "Su representacion en forma binomica es: ";

	if (b == 1.0) {
		cout << a << '+' << UNIDAD_IMAGINARIA;
	} else if (b == -1.0) {
		cout << a << '-' << UNIDAD_IMAGINARIA;
	} else if (b < -1.0) {
		cout << a << b << UNIDAD_IMAGINARIA;
	} else {
		cout << a << '+' << b << UNIDAD_IMAGINARIA;
	}

}

void polar(double modulo, double argumento) {
	while (argumento > 2 * M_PI) {
		argumento -= M_PI;
	}
	
	while (argumento < -1 * 2 * M_PI) {
		argumento += M_PI;
	}
	
	/*while (argumento < - 2 * M_PI) {
		argumento += M_PI;
	}
	
	if (argumento < 0 && argumento > - 2 * M_PI) {
		argumento *= -1;
	}*/
	
	cout << endl << "Su representacion en forma polar es: " << '[' << modulo << ';' << argumento << ']';
}

void binomicaAPolar(double a, double b) {
	double modulo = sqrt(a * a + b * b);
	double argumento = 0;

	if (a > 0 && b > 0) {
		argumento = atan(b / a);
	} else if ((a < 0 && b > 0) || (a < 0 && b < 0)) {
		argumento = atan(b / a) + M_PI;
	} else {
		argumento = atan(b / a) + 2 * M_PI;
	}

	//cout << endl << "Su representacion en forma polar es: " << '[' << modulo << ',' << argumento << ']';
	polar(modulo, argumento);
}

void polarABinomica(double modulo, double argumento) {
	double parteReal = 0;
	double parteImaginaria = 0;

	/*while (argumento > 2 * M_PI) {
		argumento -= M_PI;
	}*/
	parteReal = modulo * cos(argumento);
	parteImaginaria = modulo * sin(argumento);

	/*cout << endl << "Su representacion en forma binomica es: ";

	if (parteImaginaria == 1.0) {
		cout << parteReal << '+' << UNIDAD_IMAGINARIA;
	} else if (parteImaginaria == -1.0) {
		cout << parteReal << '-' << UNIDAD_IMAGINARIA;
	} else if (parteImaginaria < -1.0) {
		cout << parteReal << parteImaginaria << UNIDAD_IMAGINARIA;
	} else {
		cout << parteReal << '+' << parteImaginaria << UNIDAD_IMAGINARIA;
	}*/
	binomica(parteReal, parteImaginaria);
}

void funcionEDT() {
	system("cls");	// Borra el contenido de la pantalla
	unsigned short int opcion = 0;

	ComplejoBinomica binom;
	ComplejoPolar pol;

	cout << "Escriba '1' si quiere ingresar un numero complejo en forma binomica, o '2' en forma polar: ";
	cin >> opcion;

	if (opcion == 1) {
		cout << "Ingrese la parte real del numero complejo: ";
		cin >> binom.a;
		cout << endl << "Ingrese la parte imaginaria del numero complejo: ";
		cin >> binom.b;

		binomica(binom.a, binom.b);
		if (binom.a != 0.0) {
			binomicaAPolar(binom.a, binom.b);
		} else {
			binomicaAPolar(M_PI / 2, binom.b);
		}
	} else if (opcion == 2) {
		cout << endl << endl << "Ingrese el modulo del numero complejo: ";
		cin >> pol.modulo;
		cout << endl << "Ingrese el argumento del numero complejo: ";
		cin >> pol.argumento;

		polar(pol.modulo, pol.argumento);
		polarABinomica(pol.modulo, pol.argumento);
	} else {
		cout << "Datos incorrectos.";
	}
}

int main() {

	int opcion = 0;

	do {
		cout << endl << endl << "Bienvenido a la plataforma NCOM de Matematica Superior 2019." << endl << endl;
		cout << "Ingrese su criterio de consulta:" << endl << endl;
		cout << "1. Estructura, Datos y Transformaciones (EDT)" << endl;
		cout << "2. Operaciones Basicas (OB)" << endl;
		cout << "3. Operaciones Avanzadas (OA)" << endl;
		cout << "4. Suma Fasores (SF)" << endl;
		cout << "5. Salir" << endl << endl;

		cout << "Opcion: ";
		cin >> opcion;

		switch (opcion) {
			case 1:
				funcionEDT();
				break;
				//case 2:
		}
	} while (opcion != 5);	// Mientras

	return 0;
}
